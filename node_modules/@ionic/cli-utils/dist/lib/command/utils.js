"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typeDefaults = new Map()
    .set(String, null)
    .set(Boolean, false);
function normalizeOptionAliases(metadata, options) {
    if (!metadata) {
        return options;
    }
    return Object.keys(options).reduce((results, optionName) => {
        const metadataOptionFound = (metadata.options || []).find((mdOption) => (mdOption.name === optionName || (mdOption.aliases || []).includes(optionName)));
        if (metadataOptionFound) {
            results[metadataOptionFound.name] = options[optionName];
        }
        else {
            results[optionName] = options[optionName];
        }
        return results;
    }, {});
}
exports.normalizeOptionAliases = normalizeOptionAliases;
function minimistOptionsToArray(options) {
    return (Object.keys(options || {})).reduce((results, optionName) => {
        const daObject = options[optionName];
        if (optionName === '_' || !daObject) {
            return results;
        }
        if (daObject === true) {
            return results.concat(`--${optionName}`);
        }
        if (typeof daObject === 'string') {
            return results.concat(`--${optionName}=${daObject}`);
        }
        if (Array.isArray(daObject)) {
            return results.concat(daObject.map((value) => (`--${optionName}=${value}`)));
        }
        return results;
    }, []);
}
exports.minimistOptionsToArray = minimistOptionsToArray;
function normalizeOption(option) {
    if (!option.type) {
        option.type = String;
    }
    if (!option.default) {
        option.default = typeDefaults.get(option.type);
    }
    if (!option.aliases) {
        option.aliases = [];
    }
    return option;
}
function metadataToMinimistOptions(metadata) {
    let options = {
        string: [],
        boolean: [],
        alias: {},
        default: {}
    };
    if (!metadata.options) {
        return options;
    }
    for (let option of metadata.options.map(o => normalizeOption(o))) {
        if (option.type === String) {
            options.string.push(option.name);
        }
        else if (option.type === Boolean) {
            options.boolean.push(option.name);
        }
        options.default[option.name] = option.default;
        options.alias[option.name] = option.aliases;
    }
    return options;
}
exports.metadataToMinimistOptions = metadataToMinimistOptions;
function validateInputs(argv, metadata) {
    if (!metadata.inputs) {
        return;
    }
    for (let i in metadata.inputs) {
        const input = metadata.inputs[i];
        const errors = [];
        if (argv[i] && input.validators) {
            for (let validator of input.validators) {
                const r = validator(argv[i], input.name);
                if (r !== true) {
                    errors.push({
                        message: r,
                        inputName: input.name
                    });
                }
            }
            if (errors.length > 0) {
                throw errors;
            }
        }
    }
}
exports.validateInputs = validateInputs;
function filterOptionsByIntent(metadata, options, intentName) {
    return Object.keys(options).reduce((allOptions, optionName) => {
        const metadataOptionFound = (metadata.options || []).find((mdOption) => (mdOption.name === optionName || (mdOption.aliases || []).includes(optionName)));
        if (metadataOptionFound) {
            if (intentName && metadataOptionFound.intent === intentName) {
                allOptions[optionName] = options[optionName];
            }
            else if (!intentName && !metadataOptionFound.intent) {
                allOptions[optionName] = options[optionName];
            }
        }
        return allOptions;
    }, {});
}
exports.filterOptionsByIntent = filterOptionsByIntent;
